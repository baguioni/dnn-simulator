#include "interconnect.hpp"

Interconnect::Interconnect(Buffer *buffer, DRAM *dram, Controller *controller, float clock, float bandwidth) {
    this->buffer = buffer;
    this->dram = dram;

    this->clock = clock;
    this->bandwidth = bandwidth;
    this->bytes_per_cycle = bandwidth / clock;

    this->idle_cycles = 0;
    this->busy_cycles = 0;
    this->total_bytes_sent = 0;

    this->dram_incoming_request_queue = dram->GetIncomingRequestQueue();
    this->buffer_served_request_queue = buffer->GetServedRequestQueue();
    this->buffer_waiting_request_queue = buffer->GetWaitingRequestQueue();
    this->controller_request_queue = controller->GetRequestQueue();
}

void Interconnect::SendRequestToDRAM(request req) {
    dram_incoming_request_queue->push_back(MakeRequest(req.order, req.size));
}

void Interconnect::Cycle() {
    // Send requests generated by the controller to the DRAM

    while (!controller_request_queue->empty()) {
        request req = controller_request_queue->front();
        buffer_waiting_request_queue->push_back(req);
        pop_front(*controller_request_queue);
        SendRequestToDRAM(req);
    }

    // Cycle Count
    if (dram_incoming_request_queue->empty()) { // Check if Buffer is full
        idle_cycles++;
    } else {
        busy_cycles++;

        int order = dram_incoming_request_queue->front().order;
        float bytes_to_send = dram_incoming_request_queue->front().size;

        // ensures bytes_to_send is not negative
        bytes_to_send = ((bytes_to_send - bytes_per_cycle) < 0) ? 0 : (bytes_to_send - bytes_per_cycle);

        if (bytes_to_send != 0) {
            // Update the size of the request to reflect remaining bytes to send
            dram_incoming_request_queue->front().size = bytes_to_send;
        } else {
            // DRAM has finished sending data
            pop_front(*dram_incoming_request_queue);

            
            std::vector<request>::iterator it;
            for (it = buffer_waiting_request_queue->begin(); it != buffer_waiting_request_queue->end(); ++it) {
                if (it->order == order) {
                    bytes_to_send = it->size;
                    break;
                }
            }

            total_bytes_sent += bytes_to_send;

            if (it != buffer_waiting_request_queue->end()) {
                buffer_waiting_request_queue->erase(it);
                buffer_served_request_queue->push_back(MakeRequest(order, bytes_to_send));
            }

        }
    }
}

bool Interconnect::IsIdle() {
    return (dram_incoming_request_queue->empty() && controller_request_queue->empty());
}

void Interconnect::PrintStatistics() {
    std::cout << "Interconnect statistics:" << std::endl;
    std::cout << "  Total bytes sent: " << total_bytes_sent << " bytes" << std::endl;
    std::cout << "  Idle cycles: " << idle_cycles << std::endl;
    std::cout << "  Busy cycles: " << busy_cycles << std::endl;
}